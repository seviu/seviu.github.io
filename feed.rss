<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Swiftdaddy</title><description>Blog about App development for iOS</description><link>https://seviu.github.io/</link><language>en</language><lastBuildDate>Tue, 1 Sep 2020 14:10:56 +0000</lastBuildDate><pubDate>Tue, 1 Sep 2020 14:10:56 +0000</pubDate><ttl>250</ttl><atom:link href="https://seviu.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://seviu.github.io/articles/Diving%20into%20Lazy,%20Computed%20and%20Stored%20Properties</guid><title>Diving into Lazy, Computed and Stored Properties</title><description>We look into computed, lazy, and stored properties, and explore their behavior and differences we might encounter when dealing with them.</description><link>https://seviu.github.io/articles/Diving%20into%20Lazy,%20Computed%20and%20Stored%20Properties</link><pubDate>Sun, 30 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<h2>Properties, properties, properties!!!</h2><p>Swift lets you initialize properties in multiple ways. This article quickly goes through all different permutations var/let/static allowed.</p><p>Let's start with a very simple struct with methods that <code>print</code> themselves and return a constant with a different string each. And lets try all permutations:</p><pre><code><span class="keyword">struct</span> PropertyTest {
	<span class="keyword">var</span> prop1: <span class="type">String</span> {
		<span class="call">print</span>(<span class="string">"- computing1..."</span>)
		<span class="keyword">return</span> <span class="string">"prop1"</span> + <span class="keyword">#function</span>
	}
	
	<span class="keyword">var</span> prop2: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing2..."</span>)
		<span class="keyword">return</span> <span class="string">"prop2"</span> + <span class="keyword">#function</span>
	}()
	
	<span class="keyword">lazy var</span> prop3: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing3..."</span>)
		<span class="keyword">return</span> <span class="string">"prop3"</span> + <span class="keyword">#function</span>
	}()
	
<span class="comment">// ----&gt; !!! 'let' declarations cannot be computed properties
//	let prop4: String {
//		print("computing...")
//		return #function
//	}</span>
	
	<span class="keyword">let</span> prop5: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing5..."</span>)
		<span class="keyword">return</span> <span class="string">"prop5"</span> + <span class="keyword">#function</span>
	}()
	
<span class="comment">// ----&gt; !!! 'lazy' cannot be used on a let
//	lazy let prop6: String = {
//		print("computing...")
//		return #function
//	}()</span>
	
	<span class="keyword">static var</span> prop7: <span class="type">String</span> {
		<span class="call">print</span>(<span class="string">"- computing7..."</span>)
		<span class="keyword">return</span> <span class="string">"prop7"</span> + <span class="keyword">#function</span>
	}
	
	<span class="keyword">static var</span> prop8: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing8..."</span>)
		<span class="keyword">return</span> <span class="string">"prop8"</span> + <span class="keyword">#function</span>
	}()
	
<span class="comment">// ----&gt; !!! 'lazy' must not be used on an already-lazy global
//	static lazy var prop9: String = {
//		print("computing...")
//		return #function
//	}()
	
// ----&gt; !!! 'let' declarations cannot be computed properties
//	static let prop10: String {
//		print("computing...")
//		return #function
//	}</span>
	
	<span class="keyword">static let</span> prop11: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing11..."</span>)
		<span class="keyword">return</span> <span class="string">"prop11"</span> + <span class="keyword">#function</span>
	}()
	
<span class="comment">// ----&gt; !!! 'lazy' cannot be used on a let
//	static lazy let prop12: String = {
//		print("computing...")
//		return #function
//	}()</span>
}
</code></pre><p>First of all, some methods are commented with the error code. The most interesting one is the one that states that <code>lazy must not be used on an already-lazy global</code>. This means that statics are lazy by default. We will talk about it when we talk about <code>prop8</code> and <code>prop11</code></p><h2>Lets initialize our struct</h2><pre><code><span class="keyword">var</span> test = <span class="type">PropertyTest</span>()

&gt; - computing2...
&gt; - computing5...

</code></pre><p>Just by instantiating <code>PropertyTest</code>, we are greeted by the initialization of <code>prop2</code> and <code>prop5</code>.</p><p><code>prop2</code> and <code>prop5</code> are pre-set whenever we build a new distance of <code>PropertyTest</code>. They are <strong>stored properties</strong>. Non-lazy stored properties are set on initialization regardless of whether we are dealing with a struct or a class. More about stored properties later.</p><h2>prop1</h2><pre><code>		<span class="keyword">var</span> prop1: <span class="type">String</span> {
		<span class="call">print</span>(<span class="string">"- computing1..."</span>)
		<span class="keyword">return</span> <span class="string">"prop1"</span> + <span class="keyword">#function</span>
	}
</code></pre><pre><code><span class="call">print</span>(test.<span class="property">prop1</span>)
&gt; - computing1...
&gt; prop1prop1

<span class="call">print</span>(test.<span class="property">prop1</span>)
&gt; - computing1...
&gt; prop1prop1
</code></pre><p>That's it, every time we access prop1, we compute it. It is a <strong>computed property</strong> and the function name we are calling is <code>prop1</code></p><p>Computed properties cannot be changed. Therefore the <code>test.prop1 = "1"</code> assignment does not compile.</p><h2>prop2</h2><pre><code>		<span class="keyword">var</span> prop2: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing2..."</span>)
		<span class="keyword">return</span> <span class="string">"prop2"</span> + <span class="keyword">#function</span>
	}()
</code></pre><pre><code><span class="call">print</span>(test.<span class="property">prop2</span>)
&gt; prop2PropertyTest

<span class="call">print</span>(test.<span class="property">prop2</span>)
&gt; prop2PropertyTest
</code></pre><p>That's it, every time we access prop2, it is already computed. It is a <strong>stored property</strong> and the function name is <code>PropertyTest</code> because it was built in its constructor.</p><p>Stored properties can be changed. <code>test.prop2 = "1"</code> is perfectly legal.</p><h2>prop3</h2><pre><code>   <span class="keyword">lazy var</span> prop3: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing3..."</span>)
		<span class="keyword">return</span> <span class="string">"prop3"</span> + <span class="keyword">#function</span>
	}()
</code></pre><pre><code><span class="call">print</span>(test.<span class="property">prop3</span>)
&gt; - computing3...
&gt; prop3prop3

<span class="call">print</span>(test.<span class="property">prop3</span>)
&gt; prop3prop3
</code></pre><p>The first time we access prop3, it gets computed. Any successive calls will not compute it and return the same value. It is like a <strong>lazy stored property</strong></p><p>Lazy properties can be changed, therefore <code>test.prop3 = "3"</code> is valid.</p><h2>prop5</h2><pre><code>		<span class="keyword">let</span> prop5: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing5..."</span>)
		<span class="keyword">return</span> <span class="string">"prop5"</span> + <span class="keyword">#function</span>
	}()
</code></pre><pre><code><span class="keyword">var</span> test = <span class="type">PropertyTest</span>()

<span class="call">print</span>(test.<span class="property">prop5</span>)
&gt; prop5PropertyTest

<span class="call">print</span>(test.<span class="property">prop5</span>)
&gt; prop5PropertyTest
</code></pre><p>This one is exactly like prop2. It is a <strong>stored property</strong> which is built in the constructor.</p><h2>prop7</h2><pre><code>		<span class="keyword">static var</span> prop7: <span class="type">String</span> {
		<span class="call">print</span>(<span class="string">"- computing7..."</span>)
		<span class="keyword">return</span> <span class="string">"prop7"</span> + <span class="keyword">#function</span>
	}
</code></pre><pre><code><span class="call">print</span>(<span class="type">PropertyTest</span>.<span class="property">prop7</span>)
&gt; - computing7...
&gt; prop7prop7

<span class="call">print</span>(<span class="type">PropertyTest</span>.<span class="property">prop7</span>)
&gt; - computing7...
&gt; prop7prop7
</code></pre><p><code>prop7</code> is a static computed property, like with <code>prop1</code>, its value is computed every time we access it. Also, like with <code>prop1</code>, it is not possible to set its value. Computed properties are get-only properties.</p><h2>prop8</h2><pre><code>		<span class="keyword">static var</span> prop8: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing8..."</span>)
		<span class="keyword">return</span> <span class="string">"prop8"</span> + <span class="keyword">#function</span>
	}()
</code></pre><pre><code><span class="call">print</span>(<span class="type">PropertyTest</span>.<span class="property">prop8</span>)
&gt; - computing8...
&gt; prop8PropertyTest

<span class="call">print</span>(<span class="type">PropertyTest</span>.<span class="property">prop8</span>)
&gt; prop8PropertyTest
</code></pre><p>In this case, we are dealing with a static <strong>stored property</strong>. Because it is static, it is lazy by default, meaning that the first time we access it will be computed and successive calls will just reuse the computed value.</p><p>Assigning a value to <code>prop8</code> is perfectly ok. <code>PropertyTest.prop8 = "8"</code> compiles without any problem.</p><h2>prop11</h2><pre><code>		<span class="keyword">static let</span> prop11: <span class="type">String</span> = {
		<span class="call">print</span>(<span class="string">"- computing11..."</span>)
		<span class="keyword">return</span> <span class="string">"prop11"</span> + <span class="keyword">#function</span>
	}()
</code></pre><pre><code><span class="call">print</span>(<span class="type">PropertyTest</span>.<span class="property">prop11</span>)
&gt; - computing11...
&gt; prop11PropertyTest

<span class="call">print</span>(<span class="type">PropertyTest</span>.<span class="property">prop11</span>)
&gt; prop11PropertyTest
</code></pre><p><code>prop11</code>, like <code>prop8</code>, is an immutable <strong>stored property</strong></p><h2>var vs let PropertyTest()</h2><p>Something interesting happens when we declare test as immutable</p><pre><code><span class="keyword">let</span> test = <span class="type">PropertyTest</span>()
</code></pre><p>If we do this then we cannot access our lazy property, <code>prop3</code>.</p><pre><code><span class="call">print</span>(test.<span class="property">prop3</span>)  -&gt;  !!! <span class="type">Cannot</span> use <span class="keyword">mutating</span> getter on immutable value: 'test' <span class="keyword">is</span> a '<span class="keyword">let</span>' constant
</code></pre><p><strong>lazy stored properties</strong> are mutating and <code>test</code> is now a constant. Since we are dealing with a struct here, which is a value type, if we declare it as a constant, we cannot access any lazy property it might have declared, as it would mean we are changing <code>test</code>.</p><h2>initializing</h2><p>We have seen that we can change the value of stored properties. What happens when we do that on <code>prop8</code> which is static and lazy?</p><pre><code><span class="type">PropertyTest</span>.<span class="property">prop8</span> = <span class="string">"8"</span>
&gt; - computing8...

<span class="call">print</span>(test.<span class="property">prop8</span>)
&gt; <span class="number">8</span>
</code></pre><p>By accessing <code>prop8</code> we first initialize it, and then we set it. Therefore one can see that it is first being set with its default value, and then the value changes to the one we want it to have.</p><h2>Final thoughts</h2><p>No matter what the nature of the topic we dive in, there will always be underlying complexities and small differences in behavior... Even for something as trivial as something such as stored and computed properties!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://seviu.github.io/articles/Associated%20Types%20and%20Protocols</guid><title>Associated Types and Protocols</title><description>Taking a look into Protocols and how we can use them with generic types in the form of Associated Types</description><link>https://seviu.github.io/articles/Associated%20Types%20and%20Protocols</link><pubDate>Sat, 29 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<h2>Understanding the problem</h2><p>While working in a problem with a colleague we came upon a problem in which it was necessary to transform one element into an array of something complex and different. Since this was a pattern that was going to repeat itself, we defined a protocol for that.</p><p>The problem itself required us to have a <code>Parser</code> which would transform some JSON into an array of core data elements. Lets name them <code>Element</code> and <code>ComplexElement</code></p><h2>Our setup</h2><p>We have a Parser that transforms some <code>Codable</code> into an array of <code>ComplexObject</code>.</p><pre><code><span class="keyword">protocol</span> Parser {
	<span class="keyword">func</span> transform(data: <span class="type">Codable</span>?) -&gt; [<span class="type">ComplexObject</span>]
}
</code></pre><p>What we want to achieve here is to transform <code>JsonElement</code> (which is <code>Codable</code>) into <code>ComplexMessage</code> (which is <code>ComplexObject</code>)</p><pre><code><span class="keyword">struct</span> JsonElement: <span class="type">Codable</span> {
	<span class="keyword">let</span> messages:[<span class="type">String</span>]
}

<span class="keyword">struct</span> ComplexMessage: <span class="type">ComplexObject</span> {
	<span class="keyword">let</span> message: <span class="type">String</span>
}
</code></pre><h2>The naive approach</h2><p>We could be tempted to adopt our parser by directly providing the types of the objects we are dealing with like this</p><pre><code><span class="keyword">struct</span> ElementParser: <span class="type">Parser</span> {
	<span class="keyword">func</span> transform(data: <span class="type">JsonElement</span>?) -&gt; [<span class="type">ComplexMessage</span>] {
		<span class="keyword">return</span> []
	}
}
</code></pre><p>This will fail. The Swift Compiler will throw you an error Type 'ElementParser' does not conform to protocol 'Parser'`.</p><h2>The basic approach</h2><p>Let’s then correct our mistake and implement the original protocol as originally intended</p><pre><code><span class="keyword">struct</span> ElementParser: <span class="type">Parser</span> {
	<span class="keyword">func</span> transform(data: <span class="type">Codable</span>?) -&gt; [<span class="type">ComplexObject</span>] {
		<span class="keyword">return</span> []
	}
}
</code></pre><p>This still does not feel right. We really would like to specify the types of our <code>Codable</code> and our <code>ComplexObject</code></p><h3>associatedtype to the rescue</h3><p>To achieve this we can use Associated Types or <code>associatedtype</code>. An associated type is a placeholder with a keyword that can be defined with <code>typealias</code> when implementing the protocol.</p><p>Associated types can have constraints. In our example we just want them to be of type <code>Codable</code> and <code>ComplexObject</code></p><pre><code><span class="keyword">protocol</span> Parser {
	<span class="keyword">associatedtype</span> Input: <span class="type">Codable</span>
	<span class="keyword">associatedtype</span> Output: <span class="type">ComplexObject</span>

	<span class="keyword">func</span> transform(data: <span class="type">Input</span>?) -&gt; [<span class="type">Output</span>]
}
</code></pre><p>Once we are done with all this we just can implement our <code>Parser</code> protocol and fill the placeholders defined in the original protocol definition as <code>associatedtype</code></p><pre><code>

<span class="keyword">struct</span> ElementParser: <span class="type">Parser</span> {
	<span class="keyword">typealias</span> Input = <span class="type">JsonElement</span>
	<span class="keyword">typealias</span> Output = <span class="type">ComplexMessage</span>

	<span class="keyword">func</span> transform(data: <span class="type">JsonElement</span>?) -&gt; [<span class="type">ComplexMessage</span>] {
		<span class="keyword">return</span> []
	}
}
</code></pre><p>And that’s it. There is not a lot of magic around associated types. They are just placeholders we can just fill with a <code>typealias</code>.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://seviu.github.io/notes/XCTest%20Tips%20and%20Tricks</guid><title>XCTest Tips and Tricks</title><description>Small code snipets and tricks for when I write tests for my Apps</description><link>https://seviu.github.io/notes/XCTest%20Tips%20and%20Tricks</link><pubDate>Mon, 3 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<p>Some tips and tricks I have come across by running XCTest which I thought might be helpful</p><h2>Print the accessibility tree</h2><p>If you want to know which elements are there it is just as easy as put a breakpoint where you are having issues and run the following:</p><pre><code>po <span class="call">print</span>(<span class="type">XCUIApplication</span>().<span class="property">debugDescription</span>)
</code></pre><h2>Element not found?</h2><p>If an element is not found it is maybe because you configured any of its super views with an accessibility identifier.</p><p>Once a view has an accessibility identifier set then subviews will not be visible in the accessibility tree.</p><p>If they are not visible you will not be able to fetch them.</p><h2>Clear the data of your app before running the tests</h2><p>XCTest has a variable called <code>launchArguments</code>. You can pass an argument that your AppDelegate will be able to pick up on start (or any other part of your code)</p><p>On <code>willFinishLaunchingWithOptions</code>just query for this argument and if it is a XCTest then proceed to clean up your app:</p><pre><code><span class="preprocessing">#if DEBUG</span>
  <span class="keyword">if</span> <span class="type">ProcessInfo</span>.<span class="property">processInfo</span>.<span class="property">arguments</span>.<span class="call">contains</span>(<span class="string">"XCTest"</span>) {
    <span class="comment">// cleanup NSDocumentDirectory, disable animations etc...</span>
  }
<span class="preprocessing">#endif</span>
</code></pre><blockquote><p>Tip: If you have problems with legacy code and table/collection views, try to reloadData</p></blockquote>]]></content:encoded></item><item><guid isPermaLink="true">https://seviu.github.io/articles/Optionals%20under%20the%20hood</guid><title>Optionals under the hood</title><description>Exploring how Optionals are implemented, and trying to understand what is the magic that powers them.</description><link>https://seviu.github.io/articles/Optionals%20under%20the%20hood</link><pubDate>Mon, 3 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<p>In this article, we will dive a little bit into Optionals. We will start this with the following statement:</p><p><strong>Optionals are enums.</strong></p><p>This can take you by surprise. However, once you start diving into it, everything starts making sense.</p><pre><code><span class="keyword">@frozen enum</span> Optional&lt;Wrapped&gt;
</code></pre><p><em>An Optional is a type that represents either a wrapped value or nil, the absence of a value.</em></p><p>Usually, optionals are defined with a question mark <code>?</code>, but since we now know it is an enum, we might declare it as such: <code>Optional&lt;MyClass&gt;</code> instead of as <code>MyClass?</code></p><p>For this tutorial I just saw how Optional is declared in the standard library:</p><pre><code><span class="keyword">enum</span> Optional&lt;Wrapped&gt; : <span class="type">ExpressibleByNilLiteral</span> {
    <span class="comment">/// The absence of a value.
    ///
    /// In code, the absence of a value is typically written using the `nil`
    /// literal rather than the explicit `.none` enumeration case.</span>
    <span class="keyword">case</span> none

    <span class="comment">/// The presence of a value, stored as `Wrapped`.</span>
    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)
}
</code></pre><h2>ExpressibleByNilLiteral</h2><p>Optionals adopt the <code>ExpressibleByNilLiteral</code> protocol, which is a type that can be initialized using the nil literal. Only the Optional type conforms to it and it is discouraged to be used in other places.</p><p>This protocol hides unnecessary implementation details. It is what lets us assign nil to an optional.</p><p>There are more ExpressibleBy protocols out there. To dive more into it I recommend you to read this excellent article:</p><p><a href="https://swiftrocks.com/swift-expressibleby-protocols-how-they-work-internally-in-the-compiler.html">Swift ExpressibleBy protocols</a></p><h2>.none</h2><p>So now we know that <code>Optional&lt;Wrapped&gt;.none</code> is equivalent to the <code>nil</code> literal.</p><p>The difference is that <code>nil</code> is a constant having <code>.none</code> as value. To go even further we can say that <code>nil</code> is of type <code>Optional&lt;Wrapped&gt;</code>.</p><h2>Optional Binding</h2><p>Optionals are great to avoid cases in which you are dealing with <code>nil</code>. Most of the times we will conditionally bind the wrapped value of an Optional into a new variable with</p><p><code>if let</code>, <code>guard let</code>, and <code>switch</code></p><h3>if let</h3><p>I personally love this construct. It is an elegant way in which we can unwrap an optional and start using it.</p><pre><code><span class="keyword">if let</span> someConstant = someOptional {
    <span class="call">print</span>(someConstant) 
} <span class="keyword">else</span> {
    <span class="call">print</span>(<span class="string">"someOptional is nil..."</span>)
}
</code></pre><h3>guard let</h3><p>This expression will unwrap the optional so that it can be used further down in your code. If it cannot be unwrapped you must return.</p><p>This is normally used if we want to avoid the <code>if-else</code> statement and we just want to run the code with our unwrapped variable.</p><pre><code><span class="keyword">guard let</span> someConstant = someOptional <span class="keyword">else</span> { <span class="keyword">return</span> }
<span class="call">print</span>(someConstant)
<span class="comment">// ...</span>
</code></pre><h3>switch let</h3><pre><code><span class="keyword">switch</span> someOptional {
    <span class="keyword">case let</span> someConstant:
        <span class="call">print</span>(someConstant)
    <span class="keyword">default</span>:
        <span class="call">print</span>(<span class="string">"someOptional is nil..."</span>)
}
</code></pre><h2>Optional Chaining</h2><p>To access the value of an optional without crashing our code we can use the postfix optional chaining operator or <code>?</code></p><p>Lets say we want to run this code:</p><pre><code><span class="keyword">var</span> str:<span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"Hello World"</span>
<span class="call">print</span>(str.<span class="call">uppercased</span>())
</code></pre><p>This code will spectacularly fail with the following error message: <code>Value of optional type 'Optional&lt;String&gt;' must be unwrapped to refer to member 'uppercased' of wrapped base type 'String'</code></p><p>To fix it we can use <code>?</code></p><pre><code><span class="keyword">var</span> str:<span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"Hello World"</span>
<span class="call">print</span>(str?.<span class="call">uppercased</span>())
</code></pre><p>Now we get a warning: <code>Expression implicitly coerced from 'String?' to 'Any'</code> what happens is that we are printing <code>Optional("HELLO WORLD")</code>. To fix this we have three choices:</p><p>Provide a default value to avoid this warning Force-unwrap the value to avoid this warning Explicitly cast to 'Any' with 'as Any' to silence this warning<br>Providing a default value sounds like a great idea! Let's use the nil-coalescing Operator!</p><h2>The Nil-Coalescing Operator</h2><p>So we are stuck with a warning. Xcode complains of a warning. We cannot print our string until we get rid of it. We could use <code>Optional binding</code> for this, but there is a better way. The The Nil-Coalescing Operator or <code>??</code></p><pre><code><span class="keyword">var</span> str:<span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"Hello World"</span>
<span class="call">print</span>(str?.<span class="call">uppercased</span>() ?? <span class="string">""</span>)
</code></pre><p>We use <code>??</code> to unwrap the optional supply a default value in case the <code>Optional</code> instance is <code>nil</code>. We can even chain it:</p><pre><code><span class="call">print</span>(str1 ?? str2 ?? str3 ?? <span class="string">"str and str2 and str3 are all nil"</span>)
</code></pre><h2>Unconditional Unwrapping</h2><p><code>!</code> otherwise known as Force Unwrap.</p><p>This one will get most of your PR rejected and will trigger long discussions in your team. Be careful and use it if you have a very good reason that cannot be solved with Optional Binding.</p><pre><code><span class="keyword">var</span> str:<span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"Hello World"</span>
<span class="call">print</span>(str!)
</code></pre><p>Using <code>!</code> on a nil instance will crash your app with a runtime error.</p><h2>map and flatMap</h2><p>A favorite of mine, this one can scratch some heads. <code>Optional</code> defines <code>map</code> and <code>flatMap</code> and they are incredibly useful. Used properly they can greatly simplify your code and make it more concise.</p><pre><code><span class="keyword">func</span> flatMap&lt;U&gt;(<span class="keyword">_</span> transform: (<span class="type">Wrapped</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?
<span class="keyword">func</span> map&lt;U&gt;(<span class="keyword">_</span> transform: (<span class="type">Wrapped</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?
</code></pre><p><code>flatMap</code> should be used with a closure that returns an optional whereas <code>map</code> should be with a method that returns a non-optional value. Would map return an optional, it will wrap with an optional.</p><pre><code><span class="keyword">let</span> meaningoflifeString: <span class="type">String</span>? = <span class="string">"42"</span>
<span class="keyword">let</span> mapMeaningoflife = meaningoflifeString.<span class="call">map</span> { <span class="type">Int</span>($0) }
<span class="keyword">let</span> flatMapMeaningoflife = meaningoflifeString.<span class="call">flatMap</span> { <span class="type">Int</span>($0) }
<span class="call">print</span>(<span class="string">"map</span> \(mapMeaningoflife) <span class="string">or flat</span> \(flatMapMeaningoflife)<span class="string">"</span>)
<span class="comment">// prints map Optional(Optional(42)) or flat Optional(42)\n"</span>
</code></pre><h2>Playground</h2><p>Link to a <a href="https://github.com/seviu/swiftdaddy/tree/master/Playgrounds/Optional.playground">Optional Playground</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://seviu.github.io/articles/What%20is%20new%20from%20WWDC%202020</guid><title>What is new from WWDC 2020</title><description>WWDC 2020 brought us SwiftUI improvements, Swift 5.3, new Collection View APIs, and much more...</description><link>https://seviu.github.io/articles/What%20is%20new%20from%20WWDC%202020</link><pubDate>Mon, 3 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<p>WWDC brought us a lot of new things. I am still struggling to have time to watch all the sessions which were made available. This article tries to summarize some of the things they announced.</p><h2>Swift 5.3</h2><p>Starting this year we have now official Cross-Platform Support for Ubuntu, CentOS, Amazon Linux 2, Windows, and <strong>Swift AWS Lambdas</strong> on AWS</p><pre><code><span class="keyword">import</span> AWSLambdaRuntime
<span class="type">Lambda</span>.<span class="call">run</span> { 
	(<span class="keyword">_</span>, name: <span class="type">String</span>, callback) <span class="keyword">in</span>
		<span class="call">callback</span>(.<span class="call">success</span>(<span class="string">"Hello,</span> \(name)<span class="string">!"</span>)) 
}
</code></pre><p>Having experience in AWS I cannot stress how happy I am that I can now add Swift to the set of programming languages I can use. Bye, bye typescript.</p><h3>Enum Improvements</h3><p>&nbsp;</p><p><strong>Synthesized Comparable Conformance For enum Types</strong></p><p>From Swift 5.3 Comparable will also be included, allowing for easy sorting by the order of declaration.</p><p><strong>Enum Cases As Protocol Witnesses</strong></p><p>We can now allow for static protocol requirements to be witnessed by an enum case. In other words: it is possible to conform enum for a protocols so that it fulfills <code>static var</code> and <code>static func</code> protocol requirements.</p><pre><code><span class="keyword">protocol</span> ErrorReportable {
    <span class="keyword">static var</span> notFound: <span class="type">Self</span> { <span class="keyword">get</span> }
    <span class="keyword">static func</span> invalid(searchTerm: <span class="type">String</span>) -&gt; <span class="type">Self</span>
}

<span class="keyword">enum</span> UserError: <span class="type">ErrorReportable</span> {
    <span class="keyword">case</span> notFound
    <span class="keyword">case</span> invalid(searchTerm: <span class="type">String</span>)
}
</code></pre><p>Before all this, because enum cases are not considered as a "witness" for static protocol requirement, we had to write implementations such as:</p><pre><code><span class="keyword">enum</span> UserrError: <span class="type">ErrorReportable</span> {
  <span class="keyword">case</span> _notFound
  <span class="keyword">case</span> _invalid(searchTerm: <span class="type">String</span>) -&gt; <span class="type">Self</span>
  <span class="keyword">static var</span> notFound: <span class="type">Self</span> { <span class="keyword">return</span> .<span class="dotAccess">_notFound</span> }
  <span class="keyword">static func</span> invalid(searchTerm: <span class="type">String</span>) -&gt; <span class="type">Self</span> {
    <span class="keyword">return</span> .<span class="call">_invalid</span>(searchTerm: searchTerm)
  }
}
</code></pre><p>This does not really make much sense since enum cases behave like if they were <em>static</em> and matching should happen automatically.</p><p>There are some limitations. It is better to read the original proposal:</p><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0280-enum-cases-as-protocol-witnesses.md">Enum Cases as Protocol Witnesses</a></p><h3>Multiple Trailing Closures</h3><p>Before Swift 5.3 we could only have a trailing closure. Now it is possible to concatenate them. This makes the code simpler and easier to read.</p><pre><code><span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.3</span>) { 
    <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">alpha</span> = <span class="number">0</span> 
} completion: { <span class="keyword">_ in 
    self</span>.<span class="property">view</span>.<span class="call">removeFromSuperview</span>()
}
</code></pre><h3>Implicit self in Closures</h3><pre><code><span class="type">UIView</span>.<span class="call">animate</span>(withDuration: <span class="number">0.3</span>) { [<span class="keyword">self</span>] <span class="keyword">in</span>
    view.<span class="property">alpha</span> = <span class="number">0</span> 
} completion: { [<span class="keyword">self</span>] <span class="keyword">_ in</span> 
    view.<span class="call">removeFromSuperview</span>()
}
</code></pre><h3>Multi-Pattern Catch Clauses</h3><pre><code><span class="keyword">do</span> {
  <span class="keyword">try</span> <span class="call">execute</span>()
} <span class="keyword">catch</span> <span class="type">ExecError</span>.<span class="call">noParameters</span> {
  <span class="comment">// rebuild parameters</span>
} <span class="keyword">catch</span> <span class="type">ExecError</span>.<span class="call">badKey</span>(<span class="keyword">let</span> value), <span class="type">ExecError</span>.<span class="call">badValue</span>(<span class="keyword">let</span> value) {
  <span class="comment">// send error message</span>
}
</code></pre><h3>Where clauses on contextually generic declarations</h3><p>We can now attach a where clause to functions inside generic types and extensions.</p><pre><code><span class="keyword">extension</span> <span class="type">Stack</span> {
    <span class="keyword">func</span> sorted() -&gt; [<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Comparable</span> {
        array.<span class="call">sorted</span>()
    }
}
</code></pre><h3>and more...</h3><ul><li>Better diagnostic compiler errors and hence better debugging</li><li>Improved and faster code completion</li><li>Improved auto-indentation</li><li>Improved handling of chained method calls and property accesses</li><li>A standardized way to delegate a program’s entry point with the @main attribute</li><li>Swift Numerics, for numerical computation in Swift</li><li>Apple/swift-numerics: Numerical APIs for Swift</li><li>Swift Argument Parser for building command-line tools</li><li>Introducing where clauses on contextually generic declarations</li><li>Multi-Pattern catch clauses</li><li>Float16</li></ul><h2>Xcode</h2><ul><li>New UI with a new documents Tab opener</li><li>Better code completion</li><li>Xcode 12 organizer has new metrics: Including scroll hitches.</li><li>SVG Support!</li><li>Full-screen development with Xcode 12 and simulator</li><li>Add custom SwiftUI views and modifiers</li></ul><h3>MetricKit API</h3><p>MetricKit is a unique and irreplaceable tool if you care about your app performance under real circumstances in the production environment.</p><p>It can aggregate and analyze per-device reports on: - Exception and crash diagnostics - Power and performance metrics. - Tracks specific app failures, such as crashes or disk-write exceptions</p><h2>UIKit</h2><p>Brand new UIColorPickerViewController</p><p>Major improvements for Collection Views:</p><ul><li>UICollectionView.CellRegistration as an improved way to register and use Collection View cells.</li><li>Lists as new CompositionalLayouts (similar to table views)</li><li>Diffable Data Source now includes Section Snapshots</li><li>Configuration API encapsulates the content and background view properties of our Cells.</li><li>Customizations such as swipe and accessories which were previously only present for Table Views</li></ul><p>&nbsp;</p><p>UIMenu improvements with UIDeferredMenuElement let us asynchronously build menus</p><p><em>UIMenu was introduced with iOS13… Time to start using it!</em></p><p>PHPickerViewController for photos that deserve its section. This class gives us a dedicated controller for photos with multi-selection, a consistent modern UI, and <strong>no permissions</strong> required. I cannot wait to start using it.</p><h2>SwiftUI</h2><p>WWDC Would not be WWDC anymore without SwiftUI...</p><h3>App protocol: a new starting point</h3><pre><code><span class="keyword">@main
struct</span> MyApp: <span class="type">App</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">Scene</span> {
        <span class="type">WindowGroup</span> {
            <span class="type">Text</span>(<span class="string">"Hello SwiftUI!"</span>)
        }
    }
}
</code></pre><p><code>@main</code> indicates that MyApp is the starting point. It also invokes the <code>main()</code> method or starting point of a SwiftUI app. It replaces the AppDelegate and SceneDelegate with just a single struct.</p><p>The only requirement is that the body property must implement a <code>SceneBuilder</code>, which is <em>a function builder for composing a collection of scenes into a single composite scene.</em>.</p><p>In our example, we just return a WindowGroup which is the <em>container for a view hierarchy presented by your app</em></p><p>There are 4 types of built-in Scenes: - WindowGroup for presenting a group of identically structured windows - DocumentBuilder for opening, creating and saving documents - Settings for app settings - WKNotificationScene for notifications</p><h3>TextEditor</h3><p>This is a view that lets us display and edit text. From Apple's documentation:</p><pre><code><span class="keyword">struct</span> TextEditingView: <span class="type">View</span> {
    <span class="keyword">@State private var</span> fullText: <span class="type">String</span> = <span class="string">"This is some editable text..."</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">TextEditor</span>(text: $fullText)
    }
}
</code></pre><p>It does not support many of the features we already enjoy like data detector types for links. For very basic text editing needs, it fills its purpose but that's it. Still happy to have one!</p><h3>Supercharged Label with Icons</h3><p>A Label can have now an icon side by side (this is truly a blow away after so many years)</p><pre><code><span class="type">Label</span>(<span class="string">"Hello SwiftUI!"</span>, systemImage: <span class="string">"mindblown"</span>)
<span class="type">Label</span>(<span class="string">"Hello SwiftUI!"</span>, image: <span class="string">"blowaway"</span>)
</code></pre><h3>Lazy Stacks</h3><p>It is now possible to have vertical and horizontal lazy stacks, for those situations in which we have many elements we want to display in a ScrollView.</p><p>Before this, the list would just take longer to load.</p><p>There is also a new class <code>ScrollViewReader</code> which can scrollTo a position in a ScrollView</p><pre><code><span class="type">ScrollView</span> {
    <span class="type">ScrollViewReader</span> { scrollViewReader <span class="keyword">in</span>
        <span class="type">LazyVStack</span>(alignment: .<span class="dotAccess">leading</span>) {
            <span class="type">ForEach</span>(<span class="number">1</span>...<span class="number">100</span>, id: \.<span class="keyword">self</span>) {
                <span class="type">Text</span>(<span class="string">"Row</span> \($0)<span class="string">"</span>)
            }
            <span class="type">Button</span>(<span class="string">"Scroll to the middle"</span>) {
                scrollViewReader.<span class="call">scrollTo</span>(<span class="number">50</span>) <span class="comment">// ←------ new ScrollViewReader</span>
            }
        }
    }
}
</code></pre><p>Here a link to a <a href="https://github.com/seviu/swiftdaddy/tree/master/Playgrounds/ScrollView.playground">Playground</a></p><p>But there is more... We now have Grids! With LazyVGrid and LazyHGrid!</p><h3>Embedded DSL Statements</h3><p>We can now use control flow <code>if let</code> and <code>switch</code> statements inside function builders</p><pre><code><span class="type">HStack</span> {
	<span class="type">Image</span>(uiImage: landamark.<span class="property">image</span>)
	<span class="type">Text</span>(landmark.<span class="property">name</span>)
	<span class="type">Spacer</span>()
	<span class="keyword">if</span> landmark.<span class="property">isFavorite</span> {
		<span class="type">Image</span>(systemImage: <span class="string">"star.fill"</span>)
			.<span class="call">imageScale</span>(.<span class="dotAccess">medium</span>)
			.<span class="call">foregroundColor</span>(.<span class="dotAccess">yellow</span>)
	}
}
</code></pre><pre><code><span class="type">ScrollView</span> {
	<span class="type">LazyVStack</span>(spacing: <span class="number">2</span>) {
		<span class="type">ForEach</span>(rows) { row <span class="keyword">in
			switch</span> row.<span class="property">content</span> {
			<span class="keyword">case let</span> .<span class="call">singleImage</span>(image):
				<span class="type">SingleImageLayout</span>(image: image)
			<span class="keyword">case let</span> .<span class="call">imagePairing</span>(images):
				<span class="type">ImagePairingLayout</span>(images: images)
			<span class="keyword">case let</span> .<span class="call">imageRow</span>(images):
				<span class="type">ImageRowLayout</span>(images: images)
			}
		}
	}
}
</code></pre><h3>New property wrappers</h3><ul><li>AppStorage: for user defaults</li><li>ScaledMetric: a dynamic property that scales a numeric value (great for accessibility since it lets us scale things like images)</li><li>SceneStorage: for automatic state restoration</li><li>StateObject: similar to State, survive views updates</li><li>@UIApplicationDelegateAdaptor to access UIKit AppDelegate</li></ul><h3>And more</h3><ul><li>Color Picker</li><li>SignInWithAppleButton</li><li>ProgressView</li><li>OutlineGroup for trees</li><li>etc...</li></ul><h2>Networking</h2><p>From iOS 14 onwards IPv6 support will be mandatory</p><p>URLSession has HTTP/2 built-in</p><p>TLS1.3</p><p>Improvements in Multipath TCP to switch between networks</p><h3>Privacy</h3><p>Full support for encrypted DNS (DoH and DoT)</p><p>HTTP/3 experimental support</p><p>Local network privacy restrictions in which a dialog will pop up if an app wants to find and connect devices in the local network</p><h2>Testing (XCode 11.4)</h2><p>New in Xcode 12, you can see the backtrace for thrown errors, which will be quite handy since if your test fails in a function, you will be able to see which part of your test triggered it.</p><p>recordFailure deprecated in favor of record(_ issue: XCTIssue)</p><p>executionTimeAllowance</p><p>Skipping tests XCTSkip, XCTSkipIf, XCTSkipUnless</p><h2>Tracking</h2><p>Fetching the Advertisement Identifier will require asking our users</p><p>Reading from clipboard will be visible to the user when it happens</p><p>Once iOS 14 is available developers will have to enter privacy practice details into App Store Connect for display on your App Store product page.</p><h2>ARKit 4</h2><p>Location Anchors to be able to place ARKit elements in real-world coordinates and do some interesting geo-tracking.</p><p>Depth API using the LiDAR scanner already available in the iPad Pro will enable more realistic virtual object occlusion.</p><p>Better ray-casting for objects</p><p>Better Face Tracking now supporting both cameras front and back with up to three faces at once</p><h2>And more...</h2><p>Nearby interactions:</p><ul><li>Using the U1 Chip available from iPhone 11</li><li>It lets us measure distances and discovering peers with MultipeerConnectivity</li></ul><p>&nbsp;</p><p>Local Push Connectivity. It has a very limited use case only intended for places like cruise ships where there is no access to APNs.</p><p>Binary frameworks distribution with Swift package manager</p><p>Vision API to analyze motion and video</p><p>PencilKit with handwriting recognition</p><p>And of course Big Sur with Apple Silicon!</p>]]></content:encoded></item><item><guid isPermaLink="true">https://seviu.github.io/articles/Diving%20into%20Cell%20Registration%20for%20Collection%20Views</guid><title>Diving into Cell Registration for Collection Views</title><description>iOS 14 brings us Cell Registration for Collection Views. This simplifies things.</description><link>https://seviu.github.io/articles/Diving%20into%20Cell%20Registration%20for%20Collection%20Views</link><pubDate>Sat, 1 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<p>Back before <strong>iOS 14</strong> if you want to dequeue a cell for reuse you needed to register it first. It was a tedious two-step process that we all are used to.</p><p>Register</p><pre><code>collectionView.<span class="call">register</span>(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Foo"</span>)
</code></pre><p>And dequeue</p><pre><code>collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"Foo"</span>, for: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span>
</code></pre><p>iOS 14 brings us a very welcomed cell registration through an iOS 14 only UICollectionView extension:</p><pre><code><span class="keyword">public struct</span> CellRegistration&lt;Cell, Item&gt; <span class="keyword">where</span> <span class="type">Cell</span> : <span class="type">UICollectionViewCell</span>
</code></pre><p>If we are to make use of this new feature, we will need a data source. For our example, we will use UICollectionViewDiffableDataSource available since iOS 13.</p><p>iOS 14 gives us CellRegistration, a new mechanism to dequeue a reusable UICollectionViewCell.</p><p>We will need three elements when calling CellRegistration’s handle: The UICollectionView where we render our cells. The Position of the cell: our IndexPath An Item, which is our model with all the information the cell will render: ItemIdentifierType. <em>Since we are using a diffable data source, our model must adopt Hashable.</em></p><p>UICollectionViewDiffableDataSource has as parameter a CellProvider, which is a closure that builds a UICollectionViewCell and has as all the elements needed to build our collection view an IndexPath and our Item, or model</p><pre><code><span class="type">UICollectionView</span>, <span class="type">IndexPath</span> and <span class="type">ItemIdentifierType</span> (our model)
</code></pre><p>More on how to build it below.</p><p>As for UICollectionView, we have now dequeueConfiguredReusableCell, which builds a UICollectionViewCell.</p><p>dequeueConfiguredReusableCell is special. It requires an IndexPath, an Item (our model), and a CellRegistration. CellRegistration is a struct which knows how to build and configure a UICollectionViewCell. It is initialized with a registration handler. This registration handler is a closure that accepts three parameters: Cell, IndexPath, and Item. The cell must be a UICollectionViewCell and Item is our Model.</p><blockquote><p>CellRegistration can also be built with a UINib. In that case, the first parameter if its constructor is the nib, and the second one, the closure that configures our cell.</p></blockquote><pre><code><span class="keyword">let</span> cellRegistration = <span class="type">UICollectionView</span>.<span class="type">CellRegistration</span>&lt;<span class="type">UICollectionViewListCell</span>, <span class="type">MyAwesomeModel</span>&gt; 
{ (cell, indexPath, model) <span class="keyword">in
	var</span> content = cell.<span class="call">defaultContentConfiguration</span>()
	content.<span class="property">text</span> = model.<span class="property">awesomeText</span>
	cell.<span class="property">contentConfiguration</span> = content
}
</code></pre><p>This CellRegistration's configuration handler is to be called whenever we want to dequeue our reusable cell.</p><pre><code>dataSource = <span class="type">UICollectionViewDiffableDataSource</span>&lt;<span class="type">Section</span>, <span class="type">Model</span>&gt;(collectionView: collectionView) 
{ (collectionView: <span class="type">UICollectionView</span>, indexPath: <span class="type">IndexPath</span>, item: <span class="type">Model</span>) -&gt; <span class="type">UICollectionViewCell</span>? <span class="keyword">in</span>
	collectionView.<span class="call">dequeueConfiguredReusableCell</span>(using: cellRegistration, for: indexPath, item: item)
}
</code></pre><h4>Easy isn't it?</h4><p>So what happens is that our data source dequeues through dequeueConfiguredReusableCell a cell, passing a CellRegistration, an IndexPath, and an Item (our model) and CellRegistration calls its closure, which configures the UICollectionViewCell according to our model and the index path.</p><h3>But why is this better?</h3><p>Traditionally we always dequeue reusable cells with an identifier</p><pre><code>collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"MyCell"</span>, for: indexPath)
</code></pre><p>which we need to register before</p><pre><code>swift collectionView.<span class="call">register</span>(<span class="type">MyCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"MyCell"</span>)
</code></pre><p>Now our data source (diffable or not) just needs to call collectionView.dequeueConfiguredReusableCell and that takes care of it all... Provided you have a CellRegistration, which is the element that binds everything together.</p><p>The separation is clear, and it is now possible to have a central place where we define how our cells are being set up.</p><blockquote><p>But there is even more. We can apply all this to Supplementary Views such as headers or footers. Apple's WWDC sample code has even examples for badges that are rendered on top of our cells. For this we have a new UICollectionView function called dequeueConfiguredReusableSupplementary that behaves like dequeueConfiguredReusableCell but instead of returning a UICollectionViewCell returns a UICollectionReusableView</p></blockquote>]]></content:encoded></item></channel></rss>