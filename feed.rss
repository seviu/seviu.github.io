<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content"><channel><title>Swift Blog by Sebastian Vieira</title><description>Blog about the Swift programming language</description><link>https://seviu.github.io/</link><language>en</language><lastBuildDate>Mon, 3 Aug 2020 19:11:27 +0000</lastBuildDate><pubDate>Mon, 3 Aug 2020 19:11:27 +0000</pubDate><ttl>250</ttl><atom:link href="https://seviu.github.io/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://seviu.github.io/articles/Optionals</guid><title>Optionals</title><description>Diving into Optionals (WIP)</description><link>https://seviu.github.io/articles/Optionals</link><pubDate>Mon, 3 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<h2>Diving into Optionals</h2><p>In this article we will dive a little bit into Optionals. We will start this with the following statement:</p><p><strong>Optionals are enums.</strong></p><p>This can take you by surprise . However once you start diving into it, everything starts making sense.</p><pre><code><span class="keyword">@frozen enum</span> Optional&lt;Wrapped&gt;
</code></pre><p><em>An Optional is a type that represents either a wrapped value or nil, the absence of a value.</em></p><p>Usually optionals are defined with a question mark <code>?</code>, but since we now know it is an enum, we might declare it as such: <code>Optional&lt;MyClass&gt;</code> instead of as <code>MyClass?</code></p><p>For this tutorial I just saw how Optional is declared in the standard library:</p><pre><code><span class="keyword">enum</span> Optional&lt;Wrapped&gt; : <span class="type">ExpressibleByNilLiteral</span> {
    <span class="comment">/// The absence of a value.
    ///
    /// In code, the absence of a value is typically written using the `nil`
    /// literal rather than the explicit `.none` enumeration case.</span>
    <span class="keyword">case</span> none

    <span class="comment">/// The presence of a value, stored as `Wrapped`.</span>
    <span class="keyword">case</span> some(<span class="type">Wrapped</span>)
}
</code></pre><h2>ExpressibleByNilLiteral</h2><p>Optionals adopt the <code>ExpressibleByNilLiteral</code> protocol, which is a type that can be initialised using the nil literal. Only the Optional type conforms to it and it is discouraged to be used in other places.</p><p>This protocol hides unnecessary implementation details. It is what lets us assign nil to an optional.</p><p>There are more ExpressibleBy protocols out there. To dive more into it I recommend you to read this excellent article:</p><p><a href="https://swiftrocks.com/swift-expressibleby-protocols-how-they-work-internally-in-the-compiler.html">Swift ExpressibleBy protocols</a></p><h2>.none</h2><p>So now we know that <code>Optional&lt;Wrapped&gt;.none</code> is equivalent to the <code>nil</code> literal.</p><p>The difference is that <code>nil</code> is a constant having <code>.none</code> as value. To go even further we can say that <code>nil</code> is of type <code>Optional&lt;Wrapped&gt;</code> .</p><h2>Optional Binding</h2><p>Optionals are a great to avoid cases in which you are dealing with <code>nil</code>. Most of the times we will conditionally bind the wrapped value of an Optional into a new variable with</p><p><code>if let</code>, <code>guard let</code>, and <code>switch</code></p><h3>if let</h3><p>I personally love this construct. It is an elegant way in which we can unwrap an optional and start using it.</p><pre><code><span class="keyword">if let</span> someConstant = someOptional {
    <span class="call">print</span>(someConstant) 
} <span class="keyword">else</span> {
    <span class="call">print</span>(<span class="string">"someOptional is nil..."</span>)
}
</code></pre><h3>guard let</h3><p>This expression will unwrap the optional so that it can be used further down in your code. If it cannot be unwrapped you must return.</p><p>This is normally used if we want to avoid the <code>if else</code> statement and we just want to run the code with our unwrapped variable.</p><pre><code><span class="keyword">guard let</span> someConstant = someOptional <span class="keyword">else</span> { <span class="keyword">return</span> }
<span class="call">print</span>(someConstant)
<span class="comment">// ...</span>
</code></pre><h3>switch let</h3><p>Mind blows with this one. Same as if let though.</p><pre><code><span class="keyword">switch</span> someOptional {
    <span class="keyword">case let</span> someConstant:
        <span class="call">print</span>(someConstant)
    <span class="keyword">default</span>:
        <span class="call">print</span>(<span class="string">"someOptional is nil..."</span>)
}
</code></pre><h2>Optional Chaining</h2><p>To access the value of an optional without crashing our code we can use the postfix optional chaining operator or <code>?</code></p><p>Lets say we want to run this code:</p><pre><code><span class="keyword">var</span> str:<span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"Hello World"</span>
<span class="call">print</span>(str.<span class="call">uppercased</span>())
</code></pre><p>This code will spectacuraly fail with the following error message: <code>Value of optional type 'Optional&lt;String&gt;' must be unwrapped to refer to member 'uppercased' of wrapped base type 'String'</code></p><p>To fix it we can use <code>?</code></p><pre><code><span class="keyword">var</span> str:<span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"Hello World"</span>
<span class="call">print</span>(str?.<span class="call">uppercased</span>())
</code></pre><p>Now we get a warning: <code>Expression implicitly coerced from 'String?' to 'Any'</code> what happens is that we are printing <code>Optional("HELLO WORLD")</code>. To fix this we have three choices:</p><p>Provide a default value to avoid this warning Force-unwrap the value to avoid this warning Explicitly cast to 'Any' with 'as Any' to silence this warning<br>Providing a default value sounds like a great idea! Let's use the nil-coalescing Operator!</p><h2>The Nil-Coalescing Operator</h2><p>So we are stuck with a warning. Xcode complains with a warning. We cannot print our string until we get rid of it. We could use <code>Optional binding</code> for this, but there is a better way. The The Nil-Coalescing Operator or <code>??</code></p><pre><code><span class="keyword">var</span> str:<span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"Hello World"</span>
<span class="call">print</span>(str?.<span class="call">uppercased</span>() ?? <span class="string">""</span>)
</code></pre><p>We use <code>??</code> to unwrap the optional supply a default value in case the <code>Optional</code> instance is <code>nil</code>. We can even multiple chain it:</p><pre><code><span class="call">print</span>(str1 ?? str2 ?? str3 ?? <span class="string">"str and str2 and str3 are all nil"</span>)
</code></pre><h2>Unconditional Unwrapping</h2><p><code>!</code> otherwise known as Force Unwrap.</p><p>This one will get most of your PR rejected, and will trigger long discussions in your team. Be careful and use it if you have a very good reason that cannot be solved with Optional Binding.</p><pre><code><span class="keyword">var</span> str:<span class="type">Optional</span>&lt;<span class="type">String</span>&gt; = <span class="string">"Hello World"</span>
<span class="call">print</span>(str!)
</code></pre><p>Using <code>!</code> on a nil instance will definitely crash your app with a runtime error.</p><h2>map and flatMap</h2><p>A favourite of mine, this one can scratch some heads. <code>Optional</code> defines <code>map</code> and <code>flatMap</code> and they are incredibly useful. Used properly they can greatly simplify your code and make it more concise.</p><pre><code><span class="keyword">func</span> flatMap&lt;U&gt;(<span class="keyword">_</span> transform: (<span class="type">Wrapped</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>?) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?
<span class="keyword">func</span> map&lt;U&gt;(<span class="keyword">_</span> transform: (<span class="type">Wrapped</span>) <span class="keyword">throws</span> -&gt; <span class="type">U</span>) <span class="keyword">rethrows</span> -&gt; <span class="type">U</span>?
</code></pre><p><code>flatMap</code> should be used with a closure that returns an optional whereas <code>map</code> should be with a method that returns a non-optional value. Would map return an optional, it will wrap with an optional.</p><pre><code><span class="keyword">let</span> meaningoflifeString: <span class="type">String</span>? = <span class="string">"42"</span>
<span class="keyword">let</span> mapMeaningoflife = meaningoflifeString.<span class="call">map</span> { <span class="type">Int</span>($0) }
<span class="keyword">let</span> flatMapMeaningoflife = meaningoflifeString.<span class="call">flatMap</span> { <span class="type">Int</span>($0) }
<span class="call">print</span>(<span class="string">"map</span> \(mapMeaningoflife) <span class="string">or flat</span> \(flatMapMeaningoflife)<span class="string">"</span>)
<span class="comment">// prints map Optional(Optional(42)) or flat Optional(42)\n"</span>
</code></pre><h2>Playground</h2><p><a href="https://github.com/seviu/swiftdaddy/tree/master/Playgrounds/Optional.playground">Optional Playground</a></p>]]></content:encoded></item><item><guid isPermaLink="true">https://seviu.github.io/notes/XCTest</guid><title>XCTest</title><description>XCTest Tips and Tricks</description><link>https://seviu.github.io/notes/XCTest</link><pubDate>Mon, 3 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<h2>XCTest Tips and Tricks</h2><p>Some tips and tricks I have come across by running XCTest which I thought might be helpful</p><h2>Print the accessibility tree</h2><p>If you want to know which elements are there it is just as easy as put a breakpoint where you are having issues and run the following:</p><pre><code>po <span class="call">print</span>(<span class="type">XCUIApplication</span>().<span class="property">debugDescription</span>)
</code></pre><h2>Element not found?</h2><p>If an element is not found it is maybe because you marked any of its superviews has an accesibility identifier Once a view has an accesibility identifier set then subviews will not be visible in the accesibility tree.</p><p>If they are not visible you will not be able to fetch them.</p><h2>Clear the data of your app before running the tests</h2><p>XCTest has a variable called <code>launchArguments</code>. You can pass an argument that your AppDelegate will be able to pick up on start (or any other part of your code)</p><p>On <code>willFinishLaunchingWithOptions</code>just query for this argument and if it is a XCTest then proceed to clean up your app:</p><pre><code><span class="preprocessing">#if DEBUG</span>
	<span class="keyword">if</span> <span class="type">ProcessInfo</span>.<span class="property">processInfo</span>.<span class="property">arguments</span>.<span class="call">contains</span>(<span class="string">"XCTest"</span>) {
	<span class="comment">// cleanup NSDocumentDirectory, disable animations etc...</span>
	}
<span class="preprocessing">#endif</span>
</code></pre><blockquote><p>Tip: If you have problems with legacy code and table / collection views, try to reloadData:</p></blockquote>]]></content:encoded></item><item><guid isPermaLink="true">https://seviu.github.io/articles/UICollectionView</guid><title>UICollectionView</title><description>iOS 14 Cell Registration</description><link>https://seviu.github.io/articles/UICollectionView</link><pubDate>Sat, 1 Aug 2020 09:41:00 +0000</pubDate><content:encoded><![CDATA[<h2>UICollectionView CellRegistration</h2><p>Back before <strong>iOS 14</strong> if you want to dequeue a cell for reuse you needed to register it first. It was a tedious two step process which we all are used to.</p><p>Register</p><pre><code>collectionView.<span class="call">register</span>(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Foo"</span>)
</code></pre><p>And dequeue</p><pre><code>collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"Foo"</span>, for: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span>
</code></pre><p>iOS 14 brings us a very welcomed cell registration through an iOS 14 only UICollectionView extension:</p><pre><code><span class="keyword">public struct</span> CellRegistration&lt;Cell, Item&gt; <span class="keyword">where</span> <span class="type">Cell</span> : <span class="type">UICollectionViewCell</span>
</code></pre><p>If we are to make use of this new feature, we will need a data source. For our example we will use UICollectionViewDiffableDataSource available since iOS 13.</p><p>iOS 14 gives us CellRegistration, a new mechanism to dequeue a reusable UICollectionViewCell.</p><p>We will need three elements when calling CellRegistration’s handle: The UICollectionView where we render our cells. The Position of the cell: our IndexPath An Item, which is our model with all the information the cell will render: ItemIdentifierType. <em>Since we are using a diffable data source, it is important that our model adopts Hashable.</em></p><p>UICollectionViewDiffableDataSource has as parameter a CellProvider, which is a closure that builds a UICollectionViewCell and has as all the elements needed to build our collection view an IndexPath and our Item, or model</p><pre><code><span class="type">UICollectionView</span>, <span class="type">IndexPath</span> and <span class="type">ItemIdentifierType</span> (our model)
</code></pre><p>More on how to build it below.</p><p>As for UICollectionView we have now dequeueConfiguredReusableCell, which builds a UICollectionViewCell.</p><p>dequeueConfiguredReusableCell is special. It requires an IndexPath, an Item (our model) and a CellRegistration. CellRegistration is a struct which knows how to build and configure a UICollectionViewCell. It is initialised with a registration handler. This registration handler is a closure which accepts three parameters: Cell, IndexPath and Item. Cell must be a UICollectionViewCell and Item is our Model.</p><blockquote><p>CellRegistration can also be built with a UINib. In that case the first parameter if its constructor is the nib, and the second one, the closure that configures our cell.</p></blockquote><pre><code><span class="keyword">let</span> cellRegistration = <span class="type">UICollectionView</span>.<span class="type">CellRegistration</span>&lt;<span class="type">UICollectionViewListCell</span>, <span class="type">MyAwesomeModel</span>&gt; 
{ (cell, indexPath, model) <span class="keyword">in
	var</span> content = cell.<span class="call">defaultContentConfiguration</span>()
	content.<span class="property">text</span> = model.<span class="property">awesomeText</span>
	cell.<span class="property">contentConfiguration</span> = content
}
</code></pre><p>This CellRegistration's configuration handler is be called whenever we want to dequeue our reusable cell.</p><pre><code>dataSource = <span class="type">UICollectionViewDiffableDataSource</span>&lt;<span class="type">Section</span>, <span class="type">Model</span>&gt;(collectionView: collectionView) 
{ (collectionView: <span class="type">UICollectionView</span>, indexPath: <span class="type">IndexPath</span>, item: <span class="type">Model</span>) -&gt; <span class="type">UICollectionViewCell</span>? <span class="keyword">in</span>
	collectionView.<span class="call">dequeueConfiguredReusableCell</span>(using: cellRegistration, for: indexPath, item: item)
}
</code></pre><h4>Easy isn't it?</h4><p>So what happens is that our data source dequeues through dequeueConfiguredReusableCell a cell, passing a CellRegistration, an IndexPath and an Item (our model) and CellRegistration calls it's closure, which configures the UICollectionViewCell according to our model and the index path.</p><h3>But why is this better?</h3><p>Traditionally we always dequeue reusable cells with an identifier</p><pre><code>collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"MyCell"</span>, for: indexPath)
</code></pre><p>which we need to registered before</p><pre><code>swift collectionView.<span class="call">register</span>(<span class="type">MyCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"MyCell"</span>)
</code></pre><p>Now our data source (diffable or not) just needs to call collectionView.dequeueConfiguredReusableCell and that takes care of it all... Provided you have a CellRegistration, which is the element that binds everything together.</p><p>The separation is clear, and it is now possible to have a central place where we define how our cells are being set up.</p><blockquote><p>But there is even more. We can apply all this to Supplementary Views such as headers or footers. Apple's WWDC sample code has even examples for badges that are rendered on top of our cells. For this we have a new UICollectionView function called dequeueConfiguredReusableSupplementary that behaves like dequeueConfiguredReusableCell but instead of returning a UICollectionViewCell returns a UICollectionReusableView</p></blockquote>]]></content:encoded></item></channel></rss>