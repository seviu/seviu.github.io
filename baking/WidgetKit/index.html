<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="og:site_name" content="Swiftdaddy"/>
		<link rel="canonical" href="https://seviu.github.io/baking/WidgetKit"/>
		<meta name="twitter:url" content="https://seviu.github.io/baking/WidgetKit"/>
		<meta name="og:url" content="https://seviu.github.io/baking/WidgetKit"/>
		<title>WidgetKit | Swiftdaddy</title>
		<meta name="twitter:title" content="WidgetKit | Swiftdaddy"/>
		<meta name="og:title" content="WidgetKit | Swiftdaddy"/>
		<meta name="description" content="Introduction to the WidgetKit framework and the new widget API for SwiftUI"/>
		<meta name="twitter:description" content="Introduction to the WidgetKit framework and the new widget API for SwiftUI"/>
		<meta name="og:description" content="Introduction to the WidgetKit framework and the new widget API for SwiftUI"/>
		<meta name="twitter:card" content="summary"/>
		<link rel="stylesheet" href="/styles.css" type="text/css"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<link rel="shortcut icon" href="/images/favicon.png" type="image/png"/>
		<link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Swiftdaddy"/>
	</head>
	<body>
		<header>
			<div class="wrapper">
				<a class="site-name" href="/">
					<img class="logo"/>
				</a>
				<h4>Blog about App development for iOS</h4>
				<nav>
					<ul>
						<li>
							<a href="/articles">Articles</a>
						</li>
						<li>
							<a href="/notes">Notes</a>
						</li>
					</ul>
				</nav>
			</div>
		</header>
		<div class="wrapper"><h2>WidgetKit</h2><p>One of the most exciting announcements this WWDC is the introcution of WdigetKit.</p><p>Apple already has some excellent sessions on this WWDC like the <a href="https://developer.apple.com/videos/play/wwdc2020/10034/">Widgets Code-along</a> set of tutorials that show you how to build a Widget from scratch.</p><p>In this article we will explore WidgetKit and what it offers.</p><h3>SwiftUI</h3><pre><code>collectionView.<span class="call">register</span>(<span class="type">Cell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"Foo"</span>)
</code></pre><p>And dequeue</p><pre><code>collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"Foo"</span>, for: indexPath) <span class="keyword">as</span>! <span class="type">Cell</span>
</code></pre><p>iOS 14 brings us a very welcomed cell registration through an iOS 14 only UICollectionView extension:</p><pre><code><span class="keyword">public struct</span> CellRegistration&lt;Cell, Item&gt; <span class="keyword">where</span> <span class="type">Cell</span> : <span class="type">UICollectionViewCell</span>
</code></pre><p>If we are to make use of this new feature, we will need a data source. For our example we will use UICollectionViewDiffableDataSource available since iOS 13.</p><p>iOS 14 gives us CellRegistration, a new mechanism to dequeue a reusable UICollectionViewCell.</p><p>We will need three elements when calling CellRegistration’s handle: The UICollectionView where we render our cells. The Position of the cell: our IndexPath An Item, which is our model with all the information the cell will render: ItemIdentifierType. <em>Since we are using a diffable data source, it is important that our model adopts Hashable.</em></p><p>UICollectionViewDiffableDataSource has as parameter a CellProvider, which is a closure that builds a UICollectionViewCell and has as all the elements needed to build our collection view an IndexPath and our Item, or model</p><pre><code><span class="type">UICollectionView</span>, <span class="type">IndexPath</span> and <span class="type">ItemIdentifierType</span> (our model)
</code></pre><p>More on how to build it below.</p><p>As for UICollectionView we have now dequeueConfiguredReusableCell, which builds a UICollectionViewCell.</p><p>dequeueConfiguredReusableCell is special. It requires an IndexPath, an Item (our model) and a CellRegistration. CellRegistration is a struct which knows how to build and configure a UICollectionViewCell. It is initialised with a registration handler. This registration handler is a closure which accepts three parameters: Cell, IndexPath and Item. Cell must be a UICollectionViewCell and Item is our Model.</p><blockquote><p>CellRegistration can also be built with a UINib. In that case the first parameter if its constructor is the nib, and the second one, the closure that configures our cell.</p></blockquote><pre><code><span class="keyword">let</span> cellRegistration = <span class="type">UICollectionView</span>.<span class="type">CellRegistration</span>&lt;<span class="type">UICollectionViewListCell</span>, <span class="type">MyAwesomeModel</span>&gt; 
{ (cell, indexPath, model) <span class="keyword">in
	var</span> content = cell.<span class="call">defaultContentConfiguration</span>()
	content.<span class="property">text</span> = model.<span class="property">awesomeText</span>
	cell.<span class="property">contentConfiguration</span> = content
}
</code></pre><p>This CellRegistration's configuration handler is be called whenever we want to dequeue our reusable cell.</p><pre><code>dataSource = <span class="type">UICollectionViewDiffableDataSource</span>&lt;<span class="type">Section</span>, <span class="type">Model</span>&gt;(collectionView: collectionView) 
{ (collectionView: <span class="type">UICollectionView</span>, indexPath: <span class="type">IndexPath</span>, item: <span class="type">Model</span>) -&gt; <span class="type">UICollectionViewCell</span>? <span class="keyword">in</span>
	collectionView.<span class="call">dequeueConfiguredReusableCell</span>(using: cellRegistration, for: indexPath, item: item)
}
</code></pre><h4>Easy isn't it?</h4><p>So what happens is that our data source dequeues through dequeueConfiguredReusableCell a cell, passing a CellRegistration, an IndexPath and an Item (our model) and CellRegistration calls it's closure, which configures the UICollectionViewCell according to our model and the index path.</p><h3>But why is this better?</h3><p>Traditionally we always dequeue reusable cells with an identifier</p><pre><code>collectionView.<span class="call">dequeueReusableCell</span>(withReuseIdentifier: <span class="string">"MyCell"</span>, for: indexPath)
</code></pre><p>which we need to registered before</p><pre><code>swift collectionView.<span class="call">register</span>(<span class="type">MyCell</span>.<span class="keyword">self</span>, forCellWithReuseIdentifier: <span class="string">"MyCell"</span>)
</code></pre><p>Now our data source (diffable or not) just needs to call collectionView.dequeueConfiguredReusableCell and that takes care of it all... Provided you have a CellRegistration, which is the element that binds everything together.</p><p>The separation is clear, and it is now possible to have a central place where we define how our cells are being set up.</p><blockquote><p>But there is even more. We can apply all this to Supplementary Views such as headers or footers. Apple's WWDC sample code has even examples for badges that are rendered on top of our cells. For this we have a new UICollectionView function called dequeueConfiguredReusableSupplementary that behaves like dequeueConfiguredReusableCell but instead of returning a UICollectionViewCell returns a UICollectionReusableView</p></blockquote></div>
		<footer>
			<p>This website was made in Swift thanks to 
				<a href="https://github.com/johnsundell/ink">Ink</a>, 
				<a href="https://github.com/johnsundell/plot">Plot</a>, 
				<a href="https://github.com/johnsundell/splash">Splash</a> &amp; 
				<a href="https://github.com/johnsundell/publish">Publish</a> by 
				<a class="rss" href="https://www.swiftbysundell.com">John Sundell</a>
			</p>
			<p>©2020 Sebastian Vieira</p>
			<p>Subscribe via 
				<a class="rss" href="/feed.rss">RSS</a>
			</p>
		</footer>
	</body>
</html>